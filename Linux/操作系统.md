[TOC]



# 操作系统

# 一.关于操作系统的一些概念

## 1.1 抽象

计算机底层是硬件，操作系统为了不用去处理硬件实际工作中那些恼人的细节，从而都提供了使用硬盘的又一层***抽象：文件。***就是将那些数据信息片段，抽象成文件这一术语，从而方便我们去管理数据，更能体现这一个好处的例子就是Linux，***在Linux中，一切皆文件！***操作系统的任务：***创建好的抽象，并实现和管理它所创建的抽象对象。***

## 1.2 进程

## 1.3 地址空间

## 1.4 文件

文件系统，操作系统的一项主要功能是隐藏磁盘和其他I/O设备的细节特性，给程序员一个良好、清晰的独立于设备的抽象文件模型。

在读写文件之前，首先需要打开文件，检查其访问权限，如果权限许可的话，系统将会返回一个整数，称为***文件描述符。***如果进制访问，系统会返回一个错误码。

***特殊文件***，提供特殊文件是为了使得I/O设备看起来像文件一般。（块特殊文件，字符特殊文件）

## 1.5 管道

管道是一种虚文件，可以连接两个进程，实现两个进程之间的对话。

# 二. 进程

## 2.1 进程的基本知识

在***任何多道程序设计系统***中，CPU由一个进程快速切换到另一个进程，使得每一个进程各运行几十或者几百毫秒。严格的说，在某一个瞬间，CPU只能运行一个进程，但是在1秒之内，他可能运行多个进程，这样就会让我们产生***并行***的错觉。（这个其实就是我们经常所说的***并发***）

在进程模型中，计算机中所有可以运行的软件，通常包括操作系统，被组织成若干顺序进程，简称***进程***。

进程具有程序、输入、输出以及状态。单个处理器可以被若干个进程共享，它使用某一种调度算法决定何时停止一个进程的工作，并转而为另一个进程提供服务。

### 2.1.1 进程的创建

***UNIX***：`fork`函数；

Windows：相关的函数；

### 2.1.2 进程的终止

> 通常由下列条件引起：
>
> - 正常退出（自愿的）；
> - 出错退出（自愿的）；
> - 严重错误（非自愿）；
> - 被其他进程杀死（非自愿）；

***UNIX***：`exit`函数正常退出；

​			`exit`函数通知操作系统杀死某一个进程；

一般情况下，子进程在执行完最后的语句之后就会通过系统调用`exit()`请求操作系统删除自身的时候，进程终止。

还有一种情况即使父进程主动终止子进程，父进程终止子进程的原因有很多：

- 子进程使用了超过它所分配的资源；
- 分配给子进程的任务已经完成；
- ***父进程正在退出，而且操作系统不允许无父进程的子进程继续执行***

如果一个进程终止，那么他的所有子进程也应该终止，这种现象，称为级联终止。

### 2.1.3 进程的层次结构

***UNIX***：以某一个特殊进程为根进程的一个进程树，系统中所有的进程都是间接的或者直接的由该特殊进程所创建的；

![image-20221010133636001](C:\Users\z1769\AppData\Roaming\Typora\typora-user-images\image-20221010133636001.png)

***Windows***:在Windows中没有进程层次的概念，所有的进程都是地位相同的，唯一类似于进程层次的暗示是在创建进程的时候，父进程得到一个特别的令牌（句柄），该句柄可以用来控制子进程。但是他有权利将这个令牌传送给某一个其他进程，这样就不存在进程树相关的概念了。

***相反，在UNIX中，进程就不能剥夺其子进程的”继承权“。***

> 关于Windows系统下的***句柄（handle）***理解：
>
> ***句柄就相当于UNIX下的文件描述符。***
>
> 在文件I/O中，假如说要从一个文件中读取数据，应用程序首先调用操作系统函数并传送文件名字，并输入相关的文件路径。该函数返回的是什么呢？返回的是一个顺序号，就是句柄（***在这里句柄的概念和文件描述符简直一模一样，具体有哪些不一样还暂定哈！***），该句柄主要的任务就是对于打开的文件，***他是唯一的识别依据。***
>
> 我们如果想要对文件进行读写，主要就是调用相关的函数对该句柄进行操作，调用的函数将句柄以及相关的参数传送给操作系统。当完成任务之后就会将该句柄关闭。
>
> 句柄就是对于一个文件，设备，套接字或者管道的一个名字，以帮助操作系统记住我们正在处理的资源的名字，因为操作系统毕竟不是人，他没有主管意识，只认识01。

### 2.1.4 进程的状态

> ***进程主要有三种状态：***
>
> *1）运行态（该时刻进程实际占用CPU）；*
>
> *2）就绪态（可运行，但因为其他进程正在运行而暂停运行）；*
>
> *3）阻塞态（除非某种外部事件发生，否则进程不能运行）；*

系统中的进程调度程序的任务就是决定应该运行哪些程序，什么时候运行哪些程序还有该程序应该运行多长时间，但是系统中忙碌的时候，可不是简简单单的几个进程，而是几百个进程，几千个线程，几十万个句柄，系统怎么去合理的安排这些任务是重中之重。

操作系统的最底层是调度程序，在它上面有许多的进程，所有关于中断处理、启动进程和停止进程的具体细节都隐藏在调度程序中。

实际上，调度系统是一段非常短小的程序，操作系统的其他部分被简单的组织成进程的模式。

![image-20221010133958161](C:\Users\z1769\AppData\Roaming\Typora\typora-user-images\image-20221010133958161.png)

### 2.1.5 进程的实现

为了实现进程模型，为了方便管理进程，操作系统中维护着一个表格，***进程表***。或者称为***进程控制块（Process Control Block,PCB）***。每一个进程占据一个进程表项。该表项中涵盖了关于该进程的重要信息：

| 进程管理                                                     | 存储管理   | 文件管理   |
| ------------------------------------------------------------ | ---------- | ---------- |
| 寄存器                                                       | 正文段指针 | 根目录     |
| 程序计数器                                                   | 数据段指针 | 工作目录   |
| 程序状态字                                                   | 堆栈段指针 | 文件描述符 |
| 堆栈指针                                                     |            | 用户ID     |
| 进程状态                                                     |            | 组ID       |
| 优先级                                                       |            |            |
| 调度参数                                                     |            |            |
| 进程ID                                                       |            |            |
| 父进程/进程组/信号/进程开始的时间/使用的CPU时间/子进程的CPU时间/下次定时器时间 |            |            |

***PCB***中还保存有许多其他的信息，比如说***进程由运行态转化为就绪态或者阻塞态时必须保存的信息，从而保证该进程随后可以再次启动，就像从未中断一样。***

下面介绍的是***中断向量***，就是单个CPU如何维持多个顺序进程的错觉的关键，每次CPU切换进程的时候，关键就是中断向量在起作用：

> 1.硬件压入堆栈程序计数器等；
>
> 2.硬件从中断向量装入新的程序计数器；
>
> 3.汇编语言过程保存寄存器值；
>
> 4.汇编语言过程设置新的堆栈；
>
> 5.C中断服务例程运行（典型地读和缓冲输入）；
>
> 6.调度程序决定下一个将要运行的程序；
>
> 7.C语言返回至汇编代码；
>
> 8.汇编语言过程开始执行新的当前进程；

### 2.1.6 上下文切换

***当中断发生的时候，系统需要保存当前运行在CPU上的进程的上下文，以便在职处理后能够恢复上下文，即先挂起进程，再恢复进程。***

进程上下文采用进程PCB（在其他的书中，PCB指的就是进程表）表示，包括CPU寄存器的值、进程的状态和内存管理信息等等。

一般CPU切换进程的时候，先执行状态保存，保存当前CPU状态（包括内核模式以及用户模式）；之后，状态恢复重新执行该进程。

切换CPU到另一个进程需要保存当前进程状态和恢复另一个进程的状态，这个任务称为***上下文切换***。

 ***当进行上下文切换的时候，内核汇集那个旧的进程的状态保存在PCB中，然后加载经过调度而要执行的新的进程的上下文。***

### 2.1.7 示例：

![image-20221010141313388](C:\Users\z1769\AppData\Roaming\Typora\typora-user-images\image-20221010141313388.png)

![image-20221010141341860](C:\Users\z1769\AppData\Roaming\Typora\typora-user-images\image-20221010141341860.png)

上面所示C程序说明了上述UNIX系统调用。这里有两个不同的进程，一个父进程，一个子进程。二者现阶段的区别在于：子进程的pid的值为0，而父进程的pid大于0；

***注意，当进程创建子进程之后，新进程的地址空间有着两种可能：***

- 子进程是父进程的复制品（它具有与父进程同样的程序和数据）；
- 子进程记载另一个新程序；

创建子进程之后，有一个进程使用系统调用`exec()`，以用新程序来取代进程的内存空间，这样的话，子进程就可以不用按照原来父进程所描述的来执行任务了。

还有就是，没有什么可以阻止子进程不去调用`exec()`，而是乖乖的作为父进程的副本来执行。在这种情况下，父进程与子进程会并发执行，采用相同的代码指令。

## 2.2 进程间通信

### 2.2.1 进程间通信的基本概念

***协作进程***（如果一个进程可以影响其他进程或者受其他进程所影响，那么该进程是协作的）需要有一种进程间通信机制，以允许进程相互交换数据与信息。

进程间通信的两种基本模型：

***a. 共享内存***

![image-20221010144306642](C:\Users\z1769\AppData\Roaming\Typora\typora-user-images\image-20221010144306642.png)

***b. 信息传递***

![image-20221010144259839](C:\Users\z1769\AppData\Roaming\Typora\typora-user-images\image-20221010144259839.png)

### 2.2.2 三种IPC系统例子（Inter-Process-Communication）

***示例1：POSIX共享内存***

> POSIX，Portable Operating System Interface，可移植操作系统接口。
>
> 问题：不同操作系统内核为同一功能提供的系统调用函数是不一样的，比如说创建一个进程，linux下是fork函数，windows下是createprocess 函数，如果在Linux下写了一个程序用到了fork函数，要往windows上移植就得将源码里面的fork函数统统改成createprocess，然后重新编译。
>
> 解决方法：定义POSIX标准，linux和windows实现基于POSIX标准，提供同样的接口。例如定义创建进程的接口为posix_fork(示例/并非真实的函数)，并且Linux和Windows都把各自创建的进程的调用封装成posix_fork，都声明在unistd.h里面，这样我们在编写程序的时候，只需要包含unistd.h，调用这个POSIX标准中定义的API接口：posix_fork函数，即可实现源代码级别的可移植。

POSIX系统具有多种IPC机制，包括共享内存和信息传递。

***POSIX和共享内存的实现为内存映射文件，它将共享内存区域与文件相关联。***

首先通过系统调用shm_open()创建共享内存对象：

```c
shm_fd = shm_open(name,O_CREEAT | O_RDRW,0666);
```

第一个参数指定共享内存对象的名称，当进程必须访问共享内存的时候，需要通过这个名称。随后参数指定：***当它不存在的时候，需要创建共享内存（0_CREAT）***；***对象需要打开以便读写（O_RDRW）***。

`shm_open()`的成功调用返回用于共享内存对象的一个文件描述符。

一旦创建了对象，函数`ftruncate()`用于配置对象的大小（以字节为单位）。

```c
ftruncate(shm_fd,4096);
```

最后，函数`mmap()`创建内存映射文件，以便包含共享内存对象，返回一个指向内存映射文件的指针，以便用于访问共享内存对象。

***示例2：Mach 消息传递***

Mach的大多数通信，包括所有进程间通信，都是通过信息实现的。信息的发送和接收，采用邮箱（Mach称之为端口）。

***示例3：Windows 信息传递***

Windows的信息传递工具称为高级本地程序调用工具；它用于同一机器的两个进程间的通信。它类似于广泛使用的、标准的远程程序（RFC，Remote Procedure Call）调用。

### 2.2.3 远程过程调用

RPC机制类似于IPC机制，并且通常是建立在IPC之上的。

***然而。另外一个重要问题涉及服务器和客户机之间的通信。RPC方案也要有一个类似于客户机和服务器端口之间的绑定，但是客户机如何知道服务器上的端口呢？***

第一种方法：绑定信息可以按照固定的端口地址形式预先固定。

第二种方法：绑定通过交会机制动态进行。一下图片为一个示例：

![image-20221011104004165](C:\Users\z1769\AppData\Roaming\Typora\typora-user-images\image-20221011104004165.png)

### 2.2.4 管道

管道允许两个进程进行通信。（一种早期UNIX系统最早使用的一种IPC机制）

实现管道考虑的四个问题：

******

- 管道允许单向通信还是双向通信；
- 如果允许双向通信，他是***半双工（数据在同一时间内只能按照一个方向传输）***的还是***全双工（数据在同一时间可在两个方向传输）***的？
- 通信进程之间是否应该有一定的关系（如父子关系）？
- 管道通信能否通过网络，还是只能在同一台机器上运行？

#### 2.2.4.1 普通管道

普通管道允许两个进程按照标准的生产者-消费者方式进行通信；生产者向管道的一端（写入端）写，消费者从管道的另一端（读出端）读。因此普通管道是单向的，只允许单项通信，如果需要双向通信，那么就需要采取两个管道。

示例：

![image-20221011110125710](C:\Users\z1769\AppData\Roaming\Typora\typora-user-images\image-20221011110125710.png)

普通管道只能由创建进程所访问，就是谁创建的管道，谁有权力使用该管道。但是我们知道父进程在创建子进程的时候，子进程会继承父进程的所有的文件，所以管道子进程也会继承过来。

由于***管道为半双工***的，所以需要我们手动禁止子进程继承管道的写入端，否则的话就会引发冲突；父进程向管道写入的时候，应该先关闭未使用的管道读出端。

![image-20221011111010790](C:\Users\z1769\AppData\Roaming\Typora\typora-user-images\image-20221011111010790.png)

对于UNIX和Windows系统，采用普通管道的进程通信需要有父子关系。这意味着，***这些管道之可用于同一个机器的进程间通信***。

#### 2.2.4.2 命名管道

普通管道有什么弊端：

- 不能实现双向通信；
- 进程一旦完成通信并且终止，那么普通管道就不存在

***命名管道提供了一个强大的通信工具。***

- ***通信可以是双向的，但是仍然是半双工的；***
- ***没有父子关系，而且建立了一个命名管道之后，多个进程都可用它通信；***
- ***通信进程结束之后，命名管道仍然存在；***

对于***UNIX***:命名管道为***FIFO***，一旦创建，他们表现为文件系统的典型文件。而且会一直存在。直到它被显式地从文件系统中删除。

通过系统调用`mkfifo()`,可以创建FIFO，通过系统调用`open() read() write() close()`，可以操作FIFO。

注意，虽然FIFO允许双向通信，但是只允许半双工传输，如果数据要再两个方向上传输的话，也需要使用两个FIFO，此外通信进程应该位于同一台机器。

对于***Windows***：允许全双工通信，并且通信进程可以位于同一台机器或者不同的机器。

## 2.3 信号量（同步与互斥）

## 2.4 管程（信号量的升级版）

# 三. 线程

线程本质上来讲的话就是进程的升级版，由于进程的创建很耗费时间和资源，所以不得不去寻找一种更为高效的并行方法。

还有就是大多数的操作系统的内核都是多线程的，多个线程在内核中运行，每一个线程执行一个特定的任务，比如说管理设备、管理内存或处理中断等等（也就是说我们如果想要自己去设计一个操作系统的话，我们必须将内核设计成多线程的，然后任务的执行为多进程的）。

***优点：***

- 响应性，应用程序可以一直响应用户；
- 资源共享，进程只能通过共享内存或者消息传递之类的技术共享资源，但是线程默认共享他们所属进程的内存和资源。代码和数据共享的优点是：它允许一个应用程序在同一个地址空间有不同的活动进程
- 可伸缩性，对于多处理器体系结构，多线程的优点更大，因为***线程可以在多处理核上并行运行***；

> ***并行类型：数据并行和任务并行~***

## 3.1 多线程模型

***线程支持：用户层的用户线程或者内核层的内核线程。***

*（用户线程位于内核之上，他的管理无需内核支持，而内核线程是由操作系统来直接支持与管理,操作系统也是软件，可以创建进程和线程（内核线程））*

### 3.1.1 多对一模型

多对一模型映射用户级线程到一个内核进程，线程管理是由用户空间的线程库（线程池）来完成的。但是，有一个很致命的缺点，任意时间只有一个线程可以访问内核，所以多个线程不能并行运行在多处理核系统上。

![image-20221013095629800](C:\Users\z1769\AppData\Roaming\Typora\typora-user-images\image-20221013095629800.png)

### 3.1.2 一对一模型

![image-20221013095819902](C:\Users\z1769\AppData\Roaming\Typora\typora-user-images\image-20221013095819902.png)

一对一模型映射每一个用户线程到一个内核线程。该模型在一个线程执行阻塞系统调用的时候，可以允许另一个线程继续执行，所以它提供了比多对一模型更好的并发功能。***但是有一个缺点就是，创建一个用户线程就要创建一个相对应的内核线程。***又由于创建内核线程的开销会影响应用程序的性能，所以这种模型的大多数实现限制了系统支持的线程数量。

### 3.1.3 多对多模型

![image-20221013100649880](C:\Users\z1769\AppData\Roaming\Typora\typora-user-images\image-20221013100649880.png)

多对多模型就是多对一和一对一的升级版模型，可以创建任意多的用户线程，并且相应的内核线程可以在多处理器系统中并发执行，而且当一个线程执行阻塞系统调用的时候，内核可以调度另一个线程来执行。

## 3.2 线程库

> ***即提供管理和创建线程的API。***

实现线程库的方法：

- 在用户空间中提供一个没有内核支持的库，此时调用库中的函数仅仅是本地函数的调用；
- 实现由操作系统直接支持的内核级的一个库，此时调用库中的函树就是对内核的系统的调用；

目前使用的三种主要的线程库是：***POSIX Pthreads、Windows、Java***。

- Pthreads 作为POSIX标准的扩展，可以提供用户级别或者内核级别的库；
- Windows线程库是用于Windows操作系统的内核级别的线程库；
- Java线程API允许线程在Java程序中直接创建和管理，但是由于大多数的***JVM实例***运行在宿主操作系统之上，Java线程API通常都是采用宿主机的线程库来实现的，比如说，如果在Windows上的话，Java线程采用WindowsAPI来实现，而在UNIX和Linux系统中采用Pthreads实现；

***多线程创建的两个策略***：

- ***异步线程***，一旦父线程创建一个或者多个子线程之后，父线程就去执行自己本身，即父线程和子线程是并发执行的，***父线程无需知道子线程何时终止，由于线程都是独立的？？？所以线程之间通常很少有数据共享？？？。***
- 同步线程，父线程创建一个或者多个线程之后，父线程再回复自己执行之前需要等待所有的子线程的终止，这就是同步线程，通常同步线程涉及到线程之间大量的数据共享；

## 3.3 隐式多线程

### 3.3.1 线程池

*主要思想*：在进程开始的时候就创建一定数量的线程，并加入到池中以等待工作。当服务器收到请求的时候，它会唤醒池中的一个线程（如果有可用线程的话），并将需要服务的请求传递给唤醒的线程。一旦线程完成了他的任务，他就会重新返回到线程池中等待唤醒。如果没有可用的线程，那么服务器会等待，直到有空闲的线程为止。

优点：

- 解决了多线程服务器的一些致命问题：a.创建线程需要多长时间；b.如果所有的并发请求都通过新线程的话，会产生大量的线程，可能耗尽系统的资源；
- 用现有线程会比创建一个新的线程更快；
- 线程池限制了任何时候可用线程的数量，对那些不能支持大量并发线程的系统非常重要；
- 将要执行任务从创建任务的机制中分离出来；

### 3.3.2 OpenMP

OpenMP为一组编译指令和API，用于编写C、C++、Fortran等语言的程序，支持共享内存环境下的并行编程。

### 3.3.3 大中央调度

## 3.4 多线程问题

### 3.4.1 系统调用fork()和exec()

### 3.4.2 信号处理

### 3.4.3 线程撤销

线程撤销就是在线程完成之前终止线程。

### 3.4.4 线程本地存储

线程本地存储又叫做线程局部存储，Thread Local Storage，简称为TLS，实质上就是线程私有的全局变量。

不同的全局变量在多线程中是共享的，一个线程对其进行修改，所有的线程都可以看见，但是线程私有的全局变量不一样，线程私有的全局变量是线程的私有财产，每一个线程使用线程私有的全局变量的时候，都会有一个自己的副本，线程对其做出的修改仅仅是修改自己的副本，不会去修改其他线程的副本。

### 3.4.5 调度程序激活

轻量级进程（***LightWeght Process,LWP***）

## 3.5 操作系统例子

### 3.5.1 Windows线程

***Windows使用的模型是一对一的模型，每一个用户级线程映射到一个相关的内核线程。***

线程一般包括的部件：

- 线程ID，用于唯一标识线程；
- 寄存器组，用于表示处理器状态；
- 用户堆栈，以供线程在用户模式下运行；内核堆栈，以供线程在内核模式下运行；
- 私有存储区域，用于各种运行时库和动态链接库；

寄存器组、堆栈和私有存储区域，通常称为线程上下文。

线程的主要数据结构：

- ETHREAD：执行线程块；
- KTHREAD：内核线程块；
- TEB：线程环境块；

![image-20221020090232680](C:\Users\z1769\AppData\Roaming\Typora\typora-user-images\image-20221020090232680.png)

### 3.5.2 Linux线程

Linux通过系统调用clone() 提供创建线程的功能，但是Linux并不区分进程和线程。
