[TOC]



# 零.一些可能感到疑惑的问题

## 0.1 MBR

主引导记录（MBR，Master Boot Record）是采用MBR分区表的硬盘的第一个扇区，即C/H/S地址的0柱面0磁头1扇区，也叫做MBR扇区。

***MBR扇区是计算机开机之后访问硬盘时必须读取的第一个扇区。***在深入讨论主引导扇区内部结构的时候，有时候也将其开头的446字节特指为“主引导记录”(MBR)，其后是4个16字节的“磁盘分区表”（DPT）,以及2字节的结束标志（55AA）。

## 0.2 内存分段和程序分段

内存分段指的是处理器为访问内存而采用的机制，称之为内存分段机制，程序分段是软件中人为逻辑划分的内存区域，（就是我们写汇编代码时候的各种段）它本身也是内存，所以处理器访问该内存的时候，也会采取内存分段机制，用段寄存器指向该区域的起始地址，这样也就形成了内存分段。

现在由于内存分段的话，会出现「外部内存碎片和内存交换的空间太大」的问题，在内存中，由于每一个段的长度都是不固定的，所以说多个段未必能恰好使用所有的内存空间，这就会导致生成很多的物理内存碎片，导致新的程序不能被加载，这个时候我们采用内存交换的技术，就是先将音乐程序占用的那些内存先写到硬盘上，然后再从硬盘中读入内存，这就会将空闲内存使用，从而释放更大的内存空间。

但是这也就导致了一个问题，访问硬盘的速度是很慢的，如果我们的应用程序很大的话，就会效率很低下，所以说现在为了解决这些问题，就出现了内存分页的机制。

<img src="D:\a_Desktop\操作系统\内存管理\内存管理_5.png" alt="内存管理_5" style="zoom:67%;" />

## 0.3 物理地址、逻辑地址、有效地址、线性地址、虚拟地址

***物理地址***就是物理内存中真正的地址，具有唯一性。不管是在什么模式下，不管什么虚拟地址、线性地址，CPU最终都要以物理地址去访问内存，只有物理地址才是内存访问的终点站。

在***实模式***下，”段基址+段内偏移地址“经过段部件的处理，直接输出的就是物理地址，CPU可以直接使用该地址访问内存。

在***保护模式***下，“段基址+段内偏移地址”称为***线性地址***，不过，此时的段基址已经不再是真正的地址了，而是一个被称为***选择子***的东西，本质上是一个索引，类似数组的下标。通过该索引，可以在***GDT(Global Descriptor Table,全局描述符表)***中找到相对应的***段描述符***，在该描述符中记录了该段的起始、大小等信息，这样便得到了段基址。

如果没有开启***地址分页***的功能，此线性地址就被当做物理地址来使用，可直接访问内存。

如果开启了分页功能，此线性地址又多了一个名字，就是***虚拟地址***（虚拟地址、线性地址在分页机制中是一回事）。虚拟地址要经过***CPU页部件***转换成具体的物理地址，这样CPU才可以将其送上地址总线去访问内存。

无论是实模式下还是保护模式下，段内偏移地址又称为***逻辑地址***。地址都是由段基址和段内偏移地址组合而成的。由于段基址已经有默认的啦，要么是在实模式下的默认段寄存器，要么是在保护模式下的***默认段选择子寄存器指向的段描述符***中，所以只要给出段内偏移地址就行了。

线性地址或称为虚拟地址，这些都不是真正的内存地址，都是抽象出来描述程序或者任务的地址空间，由于分页模式是需要在保护模式下开启的，32位系统保护模式下的寻址空间是4GB，所以虚拟地址或者线性地址就是0~4GB的范围。

![image-20221014144329589](C:\Users\z1769\AppData\Roaming\Typora\typora-user-images\image-20221014144329589.png)

## 0.4 实模式RM和保护模式PM

> 现阶段理解，保护模式是实模式的升级，CPU复位或者加电的时候以实模式启动，此时的内存寻址方式和8086一样，由段基址和段内偏移地址所组成，但是该模式下，所有的段都是可以读、写和可执行的。
>
> 所以说为了更进一步的增加兼容性以及安全性，出现了保护模式，保护模式提供了段间的保护机制，防止程序之间胡乱访问地址，并且引进了内存保护、分页系统等等。
>
> 我们的电脑在启动的时候，CPU首先进入实模式，然后通过切换机制再进入到保护模式。
>
> 保护模式下有一个很重要的数据结构叫做GDT（Global Descriptor Table）全局描述表。

从80386开始，CPU有三种工作模式：实模式、保护模式和虚拟8086模式。

***所谓工作模式，是指CPU的寻址方式、寄存器大小、指令用法和内存布局等概念的集合。***

### 0.4.1 实模式

实模式的特点在于寻址方式，在实模式下，程序使用到的地址都是真实的物理地址，“段基址：段内偏移地址”产生的逻辑地址就是物理地址，也就是真正的内存地址。

在实模式下，用户程序和操作系统拥有同等权利，因为实模式下没有特权级。此外，程序可以随意修改自己的段基址，加上实模式下对地址的访问就是实实在在的物理地址，因此程序可以随意修改任意物理地址，甚至修改操作系统所在的物理内存，这会造成加大的安全问题。

还有就是实模式的寻址范围的问题，实模式下的寻址：段基址左移四位之后，其寻址范围达到1M。这对于现代的计算机来讲实在太小了。

### 0.4.2 保护模式

保护模式下，内存的管理模式分为两种：段模式和页模式。其中页模式是基于段模式的（实际上，很多操作系统都将段模式机制给架空了），为了改进实模式下的内存访问的不安全问题，保护模式给内存段添加了段属性来限制用户程序对内存的操作权限。

保护模式引入全局描述符表（Global Descriptor Table,GDT）,GDT的表项是描述段类型属性的数据结构----段描述符。

![image-20221024121401439](C:\Users\z1769\AppData\Roaming\Typora\typora-user-images\image-20221024121401439.png)

保护模式下的完整取值过程：

<img src="C:\Users\z1769\AppData\Roaming\Typora\typora-user-images\image-20221024155752574.png" alt="image-20221024155752574" style="zoom:80%;" />



CPU内部有一个全局描述符寄存器（GDTR）,该寄存器内保存了GDT的基地址，CPU可以通过该寄存器的内容直接找到GDT表，然后找到对应的段描述符，最终得到段基址。

## 0.5 段重叠

内存中，段仅仅是我们起的一个名字，去掉段这个名字来看的话，全部都是内存，我们此时再引进段的概念，可能分配段的时候，方案不一样，所以访问同一个数据的时候后可能会出现段A的段地址是从`0xc00`开始，段B的段地址是从`0xc02`开始的，不过偏移量不一样，但是最终都可以访问到相同的数据。

![image-20221014144958130](C:\Users\z1769\AppData\Roaming\Typora\typora-user-images\image-20221014144958130.png)

## 0.6 为什么Unix系统下的应用程序不能在Windows系统下运行

Linux下的可执行程序的格式是elf，“Executable and Linking Format”。平时我们使用`readelf`命令查看elf文件头。

Windows下的可执行程序是PE格式（portable executable，可执行文件）。

不仅仅格式不一样，系统API也不一样，Linux中的API是通过`int 0x80`这个软件中断实现的；而Windows中的API是存放在动态链接库中的（DLL，Dynamic Link Library	）。