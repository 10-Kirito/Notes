# 第五章 继承

## 5.1 基本概念

Java中的继承使用关键字`extends`代替了C++中的冒号：

```java
public class Manager extends Employee
{
  added methods and fields
}
```

需要注意的是在Java中，所有的继承全部都是公共继承，不再有C++中的私有继承和保护继承。

当我们在子类中有时候需要调用父类的方法的时候，可以使用关键字`super`，这里的`super`和C++中的`this`引用并不是一个东西，C++中的`this`指针指的是就是一个具体的对象，但是Java中的却不是这样，Java中的`super`关键字仅仅是***指示编译器调用超类方法的特殊关键字。*

> 相同的操作，在C++中是加上`::`操作符。
>
> 和C++一样，只有声明了`protected`属性和`public`属性的，子类才可以继承，才可以直接访问，否则只能通过访问器来进行访问。

需要我们注意的是，如果你在父类中定义了构造方法，那么在子类中一定也要声明一个构造方法。

```java
public Children(String _name, int _old, int _height, int _salary) {
        super(_name, _old, _height, _salary);
        bonus = 0;
}
```

## 5.2 多态的概念

在Java中，多态是自动绑定的，比如说下面所示例代码：

```java
public class TestMain {
    public static void main(String[] args) {
        Manager boss = new Manager("Linus", 45, 180, 8000);

        var staff = new Employee[3];

        staff[0] = boss;
        staff[1] = new Employee("A", 20, 170, 5000);
        staff[2] = new Employee("B", 21, 170, 5000);
      
        for (Employee e: staff)
            System.out.println(e.getName() + " " + e.getOld() + " " + e.getSalary());···
    }
}
```

以上代码中，我们可以看到`Employee`类型的变量既可以引用`Employee`类型的变量，也可以引用`Manager`类型的变量，而且当我们引用`Manager`类型的变量的时候，`e.getSalary()`调用的是`Manager`类中的方法，虚拟机会自动识别变量实际引用的类型。

这就是多态，在运行的时候会根据引用的具体的对象选择适当的方法，这被称为动态绑定。

> 在C++中，我们借助于虚函数来实现动态绑定的效果，但是在Java中动态绑定是默认的行为，如果说你不希望让一个方法是虚拟的，即不想让该函数实现动态绑定的效果，我们可以将其标记为`final`.
>
> 该关键字意思就是不让别人继承，到这里已经是最后的版本了。

需要注意的是在Java中，并不支持多重继承的概念，但是提供了一些类似于多重继承的功能，这些会在下一章节接口处介绍。

## 5.3 动态绑定和静态绑定

那些声明为`private`、`static`、`final`的方法或者构造器，这些方法编译器会准确的知道应该调用哪些方法。

***如果说我们调用的方法要依赖于隐式参数的实际类型，那么就需要在运行的时候使用动态绑定。***

假如说程序运行并且采用动态绑定调用方法的时候，虚拟机必须调用与x所引用对象的实际类型对应的那个方法，假设x的实际类型是D，他是C类的子类。如果说D类定义了方法`f(String)`,就会调用对应的方法；否则的话，就会在其父类中寻找对应的方法。是从下往上进行方法的调用。

## 5.4  阻止绑定`final`

我们有的时候希望组织人们利用某一个类来定义子类，不允许扩展的类就成为`final`类。

```java
public final class Executive extends Manager {
  // ····
  // 该类不可以被继承
}
```

方法也可以声明为`final`。如果这样做的话，子类就不可以覆盖这个方法，`final`类中的所有的方法的属性全部为`final`。

```java
public class Employee
{
  public final String getName() { return name; }
}
```

## 5.5  抽象类

在C++中，只要含有纯虚函数的类就是抽象类，该类不可以被实例化。

但是在Java中并不这样处理，在Java中，与C++类似，也是具有抽象方法，使用关键字`abstract`来声明，如果一个类中含有抽象方法的声明，那么该类就需要被声明为抽象的。

```java
public abstract class Person{
  // ····
  public abstract String getDescription();
  // 如果一个函数被声明为抽象函数，那么我们并不需要对其进行具体的定义，我们完全依靠其派生类来声明和定义。
}
```

需要注意的是，即便不含有抽象函数，我们仍然可以将一个类声明为抽象类，该类不可以被实例化.

## 5.6 受保护访问

Java中的protected属性表示修饰的类仅仅对本包和所有的子类可见.

下面是对于Java中的四个访问控制权修饰符做一个简单的总结:

1. 仅仅对本类可见----------------private;
2. 对外部完全可见----------------public;
3. 对本包和所有的子类可见----protected;
4. 对本包可见---------------默认的,不需要修饰符,我们平时写程序的时候如果不声明一般都是封装在一个默认的包中,所以我们可以看到不管我们声明的类是不是在一个文件中,我们都是可以从一个类中去访问另外的一个类.

## ------------------------------------

## 5.7 Object类: 所有类的父类

如果类没有明确的指出类的父类,就会默认认为该类的父类是Object, 即便你声明了该类是某一个类的子类, 其祖父或者曾祖父仍然是Object. 为什么该类是所有类的父类呢? 那是因为该类提供有很重要的方法.

> C++中就没有所有类的根类,不过,每一个指针都是可以转换为`void *`类型的指针的.

## 5.8 `equals`方法

在Java中类的相等比较和C++一样, 都是利用重载函数来实现的,只不过C++中重载的是运算符号.

```java
public class Employee
{
  public boolean equals(Object otherObject)
  {
    // 检测是否等于自己的引用,如果等于自己的引用,那么一定是相等的
   	if(this == otherObject) return true;
    // 考虑特殊情况,当被比较对象是空引用的话,说明是不相等的
    // 这里我平时就没有注意到
   	if(otherObject == null) return false;
    // 如果两个变量的类型不一样那么其一定是不相等的
    if(getClass() != otherObject.getClass()) return false;
    
    // 现在我们知道,该类是一个非空引用的Employee类型的变量
    // 但是我们需要进一步比较, 所以先将其转化为相应的类型
    Employee other = (Employee) otherObject;
    
    
    // 根据我们自定义的规则进行比较,如果两个员工的姓名、薪水、雇佣日期全部相等的话，我们就认为其是一样的
    // 这里也需要注意我们比较对象是否相等的时候需要去调用该类对象里面的equals函数，我们不能简单的使用等号
    // 等号仅仅可以比较两个变量的引用是否一样
    return name.equals(other.name)
      && salary == other.salary
      && hireDay.equals(other.hireDay);
  }
}
```

为了防备`name`或者`hireDay`有可能是`null`的情况，所以说我们需要使用`Object.equals`方法。如果两个参数都为null的话，会返回true；如果其中一个对象为`null`那么我们返回false；如果两个对象都不为空的时候，这个时候才调用`a.equals`。

所以说我们以上代码的最后一句话需要改为：

```java
    return Object.equals(name, other.name)
      && salary == other.salary
      && Object.equals(hireDay, other.hireDay);
```

还有一个技巧就是，当我们在子类中定义`equals`方法的时候，我们首先需要调用超类的`equals`。如果检测失败，对象就不可能相等。如果超类中的字段都相等的话，那么我们就需要比较子类中的实例字段。

```java
public class Manager extends Employee
{
  public boolean equals(Object otherObject)
  {
   	if(!super.equals(otherObject)) return false;
    
    Manager other = (Manager) otherObject;
    // 我们需要注意的是，我们定义equals方法的时候，其参数类型全部都是Object类型的参数
    return bonus == other.bonus;
  }
}
```

## 5.9 `hashCode方法`

散列值是由对象导出的一个整数值。散列码是没有规律的。如果说x和y是两个不同的对象，`x.hashCode()`和`y.hashCode()`基本上是不会相等的。一般来说，***由于`hashCode`方法定义在`Object`类当中，所以说每一个对象都具有一个默认的散列值，普通的类对象的散列码是由对象的存储地址所得到的***。

但是并不是说所有的对象的散列值都是由存储地址得到的，比如说字符串对象的散列值就是由内容导出的。

## ------------------------------------

# 第六章 接口、lambda表达式与内部类

## 6.1 接口

接口是与类并行的一个概念，其与定义类的语法很类似，仅仅是将`class`关键字替换为`interface`关键字即可。

***特点：***

- 接口中所有的方法都是抽象方法，`abstract`关键字是可以省略的；
- 所有的方法都是由`public`修饰的，也可以省略；
- 接口内的成员变量，只能是`public static final`类型的；
- 接口中不能含有构造方法；
- 接口中只能有`public abstract`类型的方法或者`public static final`类型的变量

***注意奥，接口中的方法全部都是抽象方法，所以说所有的方法我们都需要另外的去进行实现声明。***并不是说我们定义的类要使用某一个接口的话就直接拿来用了，我们要使用接口的类要自己去实现接口中的所有的方法。

```java
public class interface_test {
	public static void main(String[] args) {
		Student student = new Student();
		student.leanTime();
		student.test2(); //接口中 默认方法的调用
		System.out.println("------------------");
		
		//10.接口的匿名实现类
		Score score = new Score() {
			@Override
			public void getScore() {
				System.out.println("我是接口Score的匿名实现类score中的getscore方法");
			}
		};
		score.getScore();
	}
}

interface LearnTip{  //2.定义一个结构
	public static final int MAX_ABLE = 100;   //3.定义一个全局常量
	public static final int MIN_ABLE = 1;     //3.定义一个全局常量
	public abstract void leanTime();          //3.定义一个抽象方法

	public static void test() {  //静态方法：public static 	(修饰词static不可以省略)
		System.out.println("我是接口中的静态方法");
	}
	public default void test2() {  //静态方法：public default (修饰词default不可以省略)
		System.out.println("我是接口中的默认方法");	
	}
}
interface Score{
	public abstract void getScore();
}
class Student implements LearnTip,Score{ //5.Student 实现 接口 LearnTip和接口 Score
	@Override
	public void leanTime() {  //实现LearnTip接口中的方法
		System.out.println("我是学生，我一天学习8小时");
	}
	@Override
	public  void getScore() { //实现Scorep接口中的方法
		System.out.println("99分");
	}
}

interface Test1{
	void menthod1();   //修饰词可以省略
}
interface Test2{
	void menthod2();
}
//6.接口之间是可以实现多继承
interface Test3 extends Test1,Test2{  
	
}

//9.一个类同时继承父类和实现接口, 继承应该写在前面
class Person{}
class Worker extends Person implements LearnTip{  
	public void leanTime(){
	}
}
```

我们在书写接口类中的代码的时候，方法和变量的属性我们可以不用详细描述为`public` 和 `public static final`, 我们在接口类中就不需要再书写这些属性了，这样显得有点多余了。

实际上有的接口仅仅定义了常量，并没有定义方法。比如说标准库中的`SwingConstants`就是这样一个接口，其中仅仅包含了`NORTH`、`SOUTH`、`HORIZONTAL`等常量。如果我们的类继承了这些接口类的话，就可以直接使用相应的变量。

尽管一个类只能有一个超类，但是其可以实现多个接口，这里也是替换了C++ 中多重继承的位置。***这还没完，***Java程序设计语言具有一个非常重要的内置接口，名字为`Cloneable`, 如果说我们设计的类实现了该接口，那么Object类中的`clone`方法就可以创建你的类对象的一个准确的副本，如果希望自己设计的类拥有克隆和比较的能力。***因为我们知道，如果函数可以传递对象的引用，这是一件十分不好的事情，就会破坏掉对象的封装性。***

## 6.2 默认方法

我们可以为接口方法提供一个默认实现，必须使用`default`修饰符来标记这样一个方法。

```java
public interface Comparable<T>
{
  default int compareTo(T other) { return 0;}
  // by default, all elements are the same
}
```

当然了，如果说我们有类使用了这个接口并且重新写了该函数，那么该方法就会被覆盖掉，有的时候默认方法是十分有效的。

## 6.3 解决默认方法冲突问题

 我们可能会出现这种情况就是，我们在一个接口中将一个方法定义为默认方法，然后与此同时在超类或者另一个接口中也定义了同样的方法，这个时候规则如下：

- 超类优先；
- 如果是接口冲突的话，我们必须覆盖这个方法来解决这个冲突；

## 6.4 示例程序1 演示如何使用提供好的接口来实现指定的程序

```java
import java.awt.*;
import java.awt.event.*;
import java.time.*;
import javax.swing.*;

public class TimerTest {
    public static void main(String[] args) {
        var listener = new TimePrinter();
// 构造出一个计时器，每经过1000ms通知listener一次，一旦计时器启动之后，定时器就会定时的去调用监听器的`actionPerformed`
// 一旦计时器停止的话，定时器就不再调用监听器的`actionPerformed`
        var timer = new Timer(1000,listener);
        timer.start();

        JOptionPane.showMessageDialog(null,"Quit program?");
// 这里会出先一个对话框，如果我们点击了选项，那么程序就会继续往下执行，否则的话就会在这里陷入阻塞
// 一直到下面代码调用系统的退出函数，整个程序退出，那么很自然计时器就会自动停止，那么也就不回去执行相应的动作
        System.exit(0);
    }
}
class TimePrinter implements ActionListener
{
    @Override
    public void actionPerformed(ActionEvent e) {
        System.out.println("At the tone, the time is" + Instant.ofEpochMilli(e.getWhen()));
        Toolkit.getDefaultToolkit().beep();
    }
}

```

## 6.5 Comparator 接口

该接口是为我们如何制定比较数据的规则制定的，我们可以创建类来实现`Comparator`接口中的`compare`方法，按照我们自己定义的规则去比较排序。

比如说字符串的比较，我们可以使用String类的`compareTo`方法，但是其默认的比较规则是按照字典的顺序进行排序的，我们不能对此做出任何的修改。所以说如果我们想要以别的方式来进行比较的话，我们就需要利用Comparator接口来解决我们这个问题。

Arrays数组中像C++一样提供了所谓的比较的规则，这一点和泛型编程极为类似。

```java
// Comparator接口是这样实现的：
public interface Comparator<T>
{
  int compare(T first, T second);
}


// 然后我们如果想要其他的规则的话，我们需要对该接口进行实现，我们需要一个类
class LengthComparator implements Comparator<String>
{
  public int compare(String first, String second)
  {
    return first.length() - second.length();
  }
}


// 然后注意，我们这是一个类，不是抽象类，我们要想调用其中的方法的话，我们需要先实例化出来一个对象，然后通过该对象来调用相应的函数、

var comp = new LengthComparator();
if (comp.compare(word[i], word[j]) > 0)
  
  
  
// 接下来我们在数组中的操作就和我们的STL很类似了
String[] friend = {"Peter", "Paul", "Mary"};

Arrays.sort(friends,new LengthComparator);
// 这里就和我们在C++ 中泛型编程中，我们自定义比较算法，只不过我们在C++中是重新自定义了一个函数
// 在Java中, 因为所谓的面向对象编程，所以说这里需要类来盛放我们的方法
// 后面我们也可以看到我们同样也可以利用lambda表达式来实现
```

## 6.6 对象克隆

我们先来回忆一下为一个包含对象引用的变量建立副本的时候会发生什么，***原变量和副本都是同一个对象的引用，这就导致了任何一个变量改变都会影响到另一个变量。（这是Java特性，所以有的时候我们在列中返回某一个对象的引用是十分危险的，这严重破坏了类的封装性）***

这种情况下我们需要使用`clone`方法（该方法是属于Object的一个属性为protected的方法）进行克隆，保证副本拿到的是主题真正的拷贝，而不是说二者都引用同一块内存。

但是这就可以完全解决问题了吗？不，如果说对象中包含子对象的引用，由于Object类对要拷贝的对象是一无所知的所以说只能***逐个字段进行拷贝***，如果说所有的数据字段是数值或者其他的基本类型，那么我们拷贝这些数据没有任何问题，但是如果***包含子对象的引用的话，拷贝字段就会得到相同子对象的另外的一个引用，这样一来就导致克隆了但是没有完全克隆。***

> 属于浅拷贝，这里好像是和C++对上号了哎，C++中由于我们要考虑浅拷贝和深拷贝的问题，我们不能使用默认的拷贝函数，我们需要重新实现一个深拷贝的函数。

这个时候我们就需要像C++那样重新设计一个新的clone函数，这个函数怎么实现，很显然，我们利用接口Cloneable来实现。



接下来我们看一下如何去实现深拷贝或者浅拷贝，这里注意一下，由于最基本的clone函数是Object类的，而且属性为protected，啥意思呢，意思就是说只有子类可以访问，其他的类是不可以访问的，那也就是说我们如果别的类A（我们一般主函数都放在一个类里面）来调用类B的clone函数，这个操作是非法的，A是没有权力调用clone函数的。

所以说我们在定义一个类的时候，如果没有声明定义clone方法，那么我们就不能去调用clone函数。所以我们一般这样去定义：

```java
// 一个很简单的浅拷贝

class Employee implements Cloneable
{
  // public access, change return type
  public Employee clone() throws CloneNotSupportedException
    // 此处声明异常是因为防止编译器不知道我们相应对象的类是否实现了Cloneable接口，是防止我们没有实现对应的接口
  {
    return (Employee) super.clone();
    // 使用super关键字调用其父类的clone函数，并且将返回值设置为对应的类型
  }
}

// 一个很简单的深拷贝

class Employee implements Cloneable
{
  public Employee clone() throw CloneNotSupportedExecption
  {
    Employee cloned=(Employee) super.clone();
    
    cloned.hireDay = (Date) hireDay.clone();
    
    return cloned;
  }
}
```

## 6.7 lambda表达式

和C++一样一样的。 
