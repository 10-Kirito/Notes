# 程序的编译和链接的那些事



# FAQ：

# 1. 编译器的头文件的搜索路径

在`Ubuntu`中，当使用`GCC`编译代码时，`<>`包含的头文件将在系统默认的头文件搜索路径中寻找。这些搜索路径通常是预先配置好的，以确保编译器能够找到所需的头文件。

默认情况下，`GCC`会搜索以下目录：

1. **标准系统目录**：`GCC`会在一些标准系统目录中查找头文件，例如`/usr/include`。

2. **编译器搜索路径**：`GCC`会在编译器的默认搜索路径中查找头文件。你可以通过以下命令查看编译器的默认搜索路径：

   ```
   mathematicaCopy code
   gcc -xc -E -v -
   ```

   这将显示编译器的搜索路径列表。

   ```shell
   #include "..." search starts here:
   #include <...> search starts here:
    /usr/lib/gcc/x86_64-linux-gnu/11/include
    /usr/local/include
    /usr/include/x86_64-linux-gnu
    /usr/include
   ```

   > 这是` GCC` 编译器在 `Ubuntu` 系统上的默认头文件搜索路径列表。当你使用 `GCC` 编译代码时，编译器将在这些路径下查找所需的头文件。
   >
   > 解释每个路径的含义：
   >
   > 1. `/usr/lib/gcc/x86_64-linux-gnu/11/include`：这是 `GCC` 编译器的内部头文件路径，其中包含编译器本身的内部头文件。
   > 2. `/usr/local/include`：这是用户自行安装的软件包的头文件路径，通常用于存放本地安装的库的头文件。
   > 3. `/usr/include/x86_64-linux-gnu`：这是特定于架构的系统头文件路径，其中包含与` x86_64` 架构相关的头文件。
   > 4. `/usr/include`：这是标准系统头文件路径，其中包含标准 C 库以及其他系统库的头文件。
   >
   > 通过这些搜索路径，`GCC` 能够找到所需的头文件，让你能够顺利编译代码并链接所需的库。如果你需要在其他路径下找到头文件，可以使用 `-I` 选项来添加自定义的头文件搜索路径，就像之前提到的 `gcc -o output_file input_file.c -I /path/to/custom_headers` 一样。

   ## 第三方库都安装在哪了

   > - 可执行文件安装在`/usr/bin`
   > - 头文件安装在`/usr/include`
   > - 库文件在`/usr/lib/x86_64-linux-gnu`

3. **环境变量 `CPATH` 和 `C_INCLUDE_PATH`**：如果设置了环境变量 `CPATH` 或 `C_INCLUDE_PATH`，`GCC`将在这些路径下查找头文件。

4. **当前目录**：`GCC`会在编译代码的当前工作目录下查找头文件。

通常情况下，大多数常用的系统头文件都位于标准系统目录中，因此`GCC`能够找到它们。如果你的头文件不在标准位置，可以通过将它们添加到编译器搜索路径或设置环境变量来让`GCC`找到它们。

如果你希望在编译代码时使用自定义的头文件路径，可以使用`GCC`的`-I`选项，该选项允许你添加额外的头文件搜索路径。例如：

```
cssCopy code
gcc -o output_file input_file.c -I /path/to/custom_headers
```

这样就会将 `/path/to/custom_headers` 添加到头文件搜索路径中，使得`GCC`能够找到其中的头文件。

# 2. 使用`cmake`编译的问题

## 2.1 find_package()

`find_package()`指令的作用是用于查找并加载指定的软件包或者库。它会在系统中搜索所需要的库，并且设置相关的变量，以便我们在后续的构建过程中使用这些变量。

通常，`find_package` 指令用于查找 `CMake` 的 Find模块 或 `Config`模块，这些模块包含了查找和配置第三方库的信息。Find模块通常用于查找没有特定的配置文件的库，而`Config`模块用于查找有特定配置文件的库。

```cmake	
find_package(Boost REQUIRED COMPONENTS system filesystem)
if(Boost_FOUND)
    include_directories(${Boost_INCLUDE_DIRS})
    target_link_libraries(your_target_name ${Boost_LIBRARIES})
endif()
```

在 `CMake` 中，`include_directories` 是一个用于添加头文件搜索路径的命令。它告诉 `CMake` 在编译过程中将指定的目录添加到项目的头文件搜索路径中，以便编译器可以找到所需的头文件。

具体来说：

1. `include_directories(${Boost_INCLUDE_DIRS})`：这里的 `${Boost_INCLUDE_DIRS}` 是一个变量，由之前的 `find_package(Boost ...)` 命令设置。它包含了 Boost 库的头文件路径。通过这个命令，`CMake` 将 Boost 库的头文件路径添加到项目的头文件搜索路径中，这样在编译时就可以找到 Boost 库所需的头文件。
2. `target_link_libraries(your_target_name ${Boost_LIBRARIES})`：这个命令用于将 Boost 库链接到你的目标（即可执行文件或库）。`${Boost_LIBRARIES}` 也是一个变量，由之前的 `find_package(Boost ...)` 命令设置，它包含了需要链接的 Boost 库的名称。通过这个命令，`CMake` 将 Boost 库链接到你的目标，以便在链接过程中正确地链接 Boost 库。

> 链接库的时候不是编译器自动帮我们链接吗，为什么还要我们使用target_link_libraries?
>
> 你说得对，编译器在编译过程中会自动帮我们链接一些标准的库，比如C语言的标准库（`libc`），以及一些操作系统相关的库。这些库通常被称为系统库，而编译器会根据语言标准和操作系统的规范自动链接它们。
>
> 然而，在编译过程中，如果你使用了第三方库或其他非标准库，编译器就无法自动知道你要链接哪些库，这时就需要使用 `CMake` 或其他构建工具的 `target_link_libraries` 命令来显式地指定需要链接的库。
>
> 具体原因如下：
>
> 1. **第三方库或非标准库**：许多项目会使用第三方库来提供额外的功能，这些库并不是编译器自带的标准库。编译器并不知道你是否使用了这些库，因此需要你明确告诉编译器要链接哪些库。
> 2. **库的位置和名称**：编译器需要知道库的位置和名称才能正确链接。使用 `target_link_libraries` 可以告诉 `CMake` 去哪里找这些库，并将它们链接到目标文件中。
> 3. **可移植性和跨平台**：不同的操作系统和编译器有不同的库文件命名约定和存放位置。使用 `target_link_libraries` 可以保证你的项目在不同平台和编译器上都能正确链接所需的库。
>
> 综上所述，使用 `target_link_libraries` 是一种更灵活、明确且具有可移植性的做法，它使得项目在不同环境中都能正确地链接所需的库，而不依赖于编译器的自动链接能力。这对于复杂的项目和跨平台开发尤其重要。

## 2.2 include_directories()

在CMake中，`include_directories()`函数是用于向项目中添加包含文件的搜索路径，以便在编译过程中找到需要的头文件。具体来说，`include_directories()`函数将指定的目录路径添加到编译器的包含文件搜索路径列表当中。

```cmake
include_directories(lib/googletest/googletest/include)
```

例如，如果我们的源代码中包含类似以下的代码：

```c++
#include <gtest/gtest.h>
```

那么编译器将会在指定的包含文件搜索路径中查找`gtest/gtest.h`文件。通过在CMake中使用`include_directories()`，我们确保了编译器能够正确地找到这些头文件，从而使我们能够在项目中使用googletest库。

需要注意的是，现代的CMake偏向使用`target_include_directories()`来设置目标的包含文件路径，而不是全局设置。这可以更精确地控制每个目标的包含路径，而不会影响整个项目

# 3. 关于compile_commands.json

> https://eli.thegreenplace.net/2014/05/21/compilation-databases-for-clang-based-tools

实际上`compile_commands.json`本质上就是告诉编译器一些编译选项，比如说Warning flags、language-version flags、macro definitions(-D, 宏定义) 以及 include directories(-I)等等。如果编译项目的时候缺乏这些信息的话，就可能导致不能正确的分析整个项目的源代码。

这个时候我们会想到，直接编译的时候添加选项不就可以了吗？

```C++
#define DODIV(a, b) ((a) / (b))

int test(int z) {
  if(z == 0) {
#ifdef FOO
		return DODIV(1, z);
#else
    return 1 - z;
#endif
  }
  return 1 + z;
}
```

这段代码有一个很明显的错误就是，当`z == 0`的时候，会出现`1 / 0`的错误情况，我们希望他可以检查出此处错误。

```shell
kirito@kirito:~/test$ clang-check -analyze div.c
Error while trying to load a compilation database:
Could not auto-detect compilation database for file "div.c"
No compilation database found in /home/kirito/test or any parent directory
fixed-compilation-database: Error while opening fixed database: No such file or directory
json-compilation-database: Error while opening JSON database: No such file or directory
Running without flags.
```

我们利用`clang-check`工具进行检查代码当中的错误的时候会提示我们寻找不到相应的`compilation database`，也就是相对应的`compile_commands.json`文件内容找不到，因此他无法进行检查。

> https://clang.llvm.org/extra/clang-tidy/ 
>
> 类似于clang-check在使用的时候可以选择添加`--`来通知工具，我们将会使用自己的编译选项.

当然我们也可以在后面添加`--`来通知它我们会使用自己的参数来编译，而不需要`compilation database`来协助我们：

```shell
kirito@kirito:~/test$ clang-check -analyze div.c -- -DFOO
/home/kirito/test/div.c:6:12: warning: Division by zero [core.DivideZero]
    return DODIV(1, z);
           ^~~~~~~~~~~
/home/kirito/test/div.c:1:26: note: expanded from macro 'DODIV'
#define DODIV(a, b) ((a) / (b))
                     ~~~~^~~~~
1 warning generated.
```

这里我们可以看到，当我们在后面添加了`--`之后, 添加了属于我们自己的编译参数，之后结果也是检测出来了我们的错误。

> So providing compilation commands to tools on the command-line is easy. However, if you want to run analyses/transformations over larger projects for which some sort of build system already exists, you'll probably find a real compilation database more useful.

大致的意思是对于小项目来讲，我们编译的时候提供相应的编译命令会很简单，但是对于一些大型的项目的话，我们会发现`compilation database`的妙处所在!

***关于 JSON compilation database：***

When Clang tools complain they can't find a compilation database, what they actually mean is a specially named JSON file in either the same directory as the file being processed or in one of its parent directories. The [JSON compilation database](http://clang.llvm.org/docs/JSONCompilationDatabase.html) is very simple. Here's an example:

```code
[
{
  "directory": "/tmp",
  "command": "gcc div0.c",
  "file": "/tmp/div0.c"
},
{
  "directory": "/tmp",
  "command": "gcc -DFOO div0.c",
  "file": "/tmp/div0.c"
}
]
```

It's just a list of entries, each of which consists of these fields:

- File: the file to which the compilation applies
- Command: the exact compilation command used
- Directory: the directory from which the compilation is executed [[3\]](https://eli.thegreenplace.net/2014/05/21/compilation-databases-for-clang-based-tools#id8)

As you can see above, there may be multiple entries for the same file. This is not a mistake - it's entirely plausible that the same file gets compiled multiple times inside a project, each time with different options.

If you paste this into a file name `compile_commands.json` and place it in the same directory (or any of its parents) with the file you want to run the analysis on, the tool will work without requiring the `--` part, because it can find the file in the compilation database and infer the compilation command on its own. If the tool finds more than one entry for a file, it just runs multiple times, once per entry. As far as the tool is concerned, two compilations of the same file can be entirely different due to differences in flags.

比如说针对上面的例子所生成的`compile_commands.json`:

```code
[
  {
    "directory": "/home/kirito/test/test",
    "arguments": [
      "/usr/bin/gcc",
      "-c",
      "-m64",
      "-fvisibility=hidden",
      "-O3",
      "-DNDEBUG",
      "-o",
      "build/.objs/./test/linux/x86_64/release/src/main.c.o",
      "src/main.c"
    ],
    "file": "src/main.c"
  },
  {
    "directory": "/home/kirito/test/test",
    "arguments": [
      "/usr/bin/gcc",
      "-c",
      "-m64",
      "-fvisibility=hidden",
      "-O3",
      "-DNDEBUG",
      "-DFOO",
      "-o",
      "build/.objs/./test/linux/x86_64/release/src/main.c.o",
      "src/main.c"
    ],
    "file": "src/main.c"
  }
```

这个是`xmake`自动生成的一份`compile_commands.json`文件，我们可以看到其中有一个是带有宏定义的，另一种是没有宏定义的，所以我们重新运行`clang-check`工具进行检查：

```shell
kirito@kirito:~/test/test$ ls -l
total 20
drwxrwxr-x 6 kirito kirito 4096 Mar  4 05:46 build
-rw-r--r-- 1 kirito kirito  625 Mar  4 05:46 compile_commands.json
-rw-rw-r-- 1 kirito kirito 2116 Mar  4 05:46 main.plist
drwxrwxr-x 2 kirito kirito 4096 Mar  4 05:45 src
-rw-r--r-- 1 kirito kirito 1885 Mar  4 05:49 xmake.lua
kirito@kirito:~/test/test$ clang-check -analyze src/main.c
src/main.c:5:12: warning: Division by zero [core.DivideZero]
  return 1 / 0;
         ~~^~~
1 warning generated.
```

我们可以看到运行了两次，一次是没有宏定义，另一种是没有宏定义，这在我们开发项目的时候就很有用，会动态的帮助我们检查项目的错误。



## 3.1 error: *.h files not found in the IDE

一般这个问题的原因是在于LSP未识别到对应项目的`compile_commands.json`文件，在vscode当中，如果使用的clang作为LSP的话，其默认识别目录位于项目的根目录下，你可以将相应的`compile_commands.json`文件复制至项目的根目录下，或者修改clang的默认识别该文件的目录，将其修改为`compile_commands.json`文件所在的路径之下。