# 程序的编译和链接的那些事



# FAQ：

# 1. 编译器的头文件的搜索路径

在`Ubuntu`中，当使用`GCC`编译代码时，`<>`包含的头文件将在系统默认的头文件搜索路径中寻找。这些搜索路径通常是预先配置好的，以确保编译器能够找到所需的头文件。

默认情况下，`GCC`会搜索以下目录：

1. **标准系统目录**：`GCC`会在一些标准系统目录中查找头文件，例如`/usr/include`。

2. **编译器搜索路径**：`GCC`会在编译器的默认搜索路径中查找头文件。你可以通过以下命令查看编译器的默认搜索路径：

   ```
   mathematicaCopy code
   gcc -xc -E -v -
   ```

   这将显示编译器的搜索路径列表。

   ```shell
   #include "..." search starts here:
   #include <...> search starts here:
    /usr/lib/gcc/x86_64-linux-gnu/11/include
    /usr/local/include
    /usr/include/x86_64-linux-gnu
    /usr/include
   ```

   > 这是` GCC` 编译器在 `Ubuntu` 系统上的默认头文件搜索路径列表。当你使用 `GCC` 编译代码时，编译器将在这些路径下查找所需的头文件。
   >
   > 解释每个路径的含义：
   >
   > 1. `/usr/lib/gcc/x86_64-linux-gnu/11/include`：这是 `GCC` 编译器的内部头文件路径，其中包含编译器本身的内部头文件。
   > 2. `/usr/local/include`：这是用户自行安装的软件包的头文件路径，通常用于存放本地安装的库的头文件。
   > 3. `/usr/include/x86_64-linux-gnu`：这是特定于架构的系统头文件路径，其中包含与` x86_64` 架构相关的头文件。
   > 4. `/usr/include`：这是标准系统头文件路径，其中包含标准 C 库以及其他系统库的头文件。
   >
   > 通过这些搜索路径，`GCC` 能够找到所需的头文件，让你能够顺利编译代码并链接所需的库。如果你需要在其他路径下找到头文件，可以使用 `-I` 选项来添加自定义的头文件搜索路径，就像之前提到的 `gcc -o output_file input_file.c -I /path/to/custom_headers` 一样。

   ## 第三方库都安装在哪了

   > - 可执行文件安装在`/usr/bin`
   > - 头文件安装在`/usr/include`
   > - 库文件在`/usr/lib/x86_64-linux-gnu`

3. **环境变量 `CPATH` 和 `C_INCLUDE_PATH`**：如果设置了环境变量 `CPATH` 或 `C_INCLUDE_PATH`，`GCC`将在这些路径下查找头文件。

4. **当前目录**：`GCC`会在编译代码的当前工作目录下查找头文件。

通常情况下，大多数常用的系统头文件都位于标准系统目录中，因此`GCC`能够找到它们。如果你的头文件不在标准位置，可以通过将它们添加到编译器搜索路径或设置环境变量来让`GCC`找到它们。

如果你希望在编译代码时使用自定义的头文件路径，可以使用`GCC`的`-I`选项，该选项允许你添加额外的头文件搜索路径。例如：

```
cssCopy code
gcc -o output_file input_file.c -I /path/to/custom_headers
```

这样就会将 `/path/to/custom_headers` 添加到头文件搜索路径中，使得`GCC`能够找到其中的头文件。

# 2. 使用`cmake`编译的问题

## 2.1 find_package()

`find_package()`指令的作用是用于查找并加载指定的软件包或者库。它会在系统中搜索所需要的库，并且设置相关的变量，以便我们在后续的构建过程中使用这些变量。

通常，`find_package` 指令用于查找 `CMake` 的 Find模块 或 `Config`模块，这些模块包含了查找和配置第三方库的信息。Find模块通常用于查找没有特定的配置文件的库，而`Config`模块用于查找有特定配置文件的库。

```cmake	
find_package(Boost REQUIRED COMPONENTS system filesystem)
if(Boost_FOUND)
    include_directories(${Boost_INCLUDE_DIRS})
    target_link_libraries(your_target_name ${Boost_LIBRARIES})
endif()
```

在 `CMake` 中，`include_directories` 是一个用于添加头文件搜索路径的命令。它告诉 `CMake` 在编译过程中将指定的目录添加到项目的头文件搜索路径中，以便编译器可以找到所需的头文件。

具体来说：

1. `include_directories(${Boost_INCLUDE_DIRS})`：这里的 `${Boost_INCLUDE_DIRS}` 是一个变量，由之前的 `find_package(Boost ...)` 命令设置。它包含了 Boost 库的头文件路径。通过这个命令，`CMake` 将 Boost 库的头文件路径添加到项目的头文件搜索路径中，这样在编译时就可以找到 Boost 库所需的头文件。
2. `target_link_libraries(your_target_name ${Boost_LIBRARIES})`：这个命令用于将 Boost 库链接到你的目标（即可执行文件或库）。`${Boost_LIBRARIES}` 也是一个变量，由之前的 `find_package(Boost ...)` 命令设置，它包含了需要链接的 Boost 库的名称。通过这个命令，`CMake` 将 Boost 库链接到你的目标，以便在链接过程中正确地链接 Boost 库。

> 链接库的时候不是编译器自动帮我们链接吗，为什么还要我们使用target_link_libraries?
>
> 你说得对，编译器在编译过程中会自动帮我们链接一些标准的库，比如C语言的标准库（`libc`），以及一些操作系统相关的库。这些库通常被称为系统库，而编译器会根据语言标准和操作系统的规范自动链接它们。
>
> 然而，在编译过程中，如果你使用了第三方库或其他非标准库，编译器就无法自动知道你要链接哪些库，这时就需要使用 `CMake` 或其他构建工具的 `target_link_libraries` 命令来显式地指定需要链接的库。
>
> 具体原因如下：
>
> 1. **第三方库或非标准库**：许多项目会使用第三方库来提供额外的功能，这些库并不是编译器自带的标准库。编译器并不知道你是否使用了这些库，因此需要你明确告诉编译器要链接哪些库。
> 2. **库的位置和名称**：编译器需要知道库的位置和名称才能正确链接。使用 `target_link_libraries` 可以告诉 `CMake` 去哪里找这些库，并将它们链接到目标文件中。
> 3. **可移植性和跨平台**：不同的操作系统和编译器有不同的库文件命名约定和存放位置。使用 `target_link_libraries` 可以保证你的项目在不同平台和编译器上都能正确链接所需的库。
>
> 综上所述，使用 `target_link_libraries` 是一种更灵活、明确且具有可移植性的做法，它使得项目在不同环境中都能正确地链接所需的库，而不依赖于编译器的自动链接能力。这对于复杂的项目和跨平台开发尤其重要。

## 2.2 include_directories()

在CMake中，`include_directories()`函数是用于向项目中添加包含文件的搜索路径，以便在编译过程中找到需要的头文件。具体来说，`include_directories()`函数将指定的目录路径添加到编译器的包含文件搜索路径列表当中。

```cmake
include_directories(lib/googletest/googletest/include)
```

例如，如果我们的源代码中包含类似以下的代码：

```c++
#include <gtest/gtest.h>
```

那么编译器将会在指定的包含文件搜索路径中查找`gtest/gtest.h`文件。通过在CMake中使用`include_directories()`，我们确保了编译器能够正确地找到这些头文件，从而使我们能够在项目中使用googletest库。

需要注意的是，现代的CMake偏向使用`target_include_directories()`来设置目标的包含文件路径，而不是全局设置。这可以更精确地控制每个目标的包含路径，而不会影响整个项目