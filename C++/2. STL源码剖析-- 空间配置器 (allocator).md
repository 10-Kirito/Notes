# 第二讲 空间分配器(allocator)

## 加油站1：关于new和delete

<h3 id="1.1">1.1 测试</h3>

<span is="jump">11</span>

> 知识点补充站：
>
> 参考刘元笔记：https://github.com/LiuYuan-SHU/MyNotes/blob/master/C%2B%2B/C%2B%2B%E6%96%B0%E7%BB%8F%E5%85%B8/%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/18_%E5%86%85%E5%AD%98%E9%AB%98%E7%BA%A7%E8%AF%9D%E9%A2%98.md
>
> 通常情况下，C++内存分配和释放的操作如下：
>
> ```C++
> class Foo{···};
> Foo *pf = new Foo;
> delete pf;
> ```
>
> 其中操作符`new/delete`和`operator new/operator delete`有什么关系呢？
>
> 1. `new` 做了两件事情：
>
> - 调用`operator new`分配内存；
> - 调用构造函数构造对象；
>
> 2. `delete`做了两件事情：
>
> - 调用析构函数析构对象；
> - 调用`operator delete`释放内存；
>
> ***这里需要我们注意的是operator new和operator delete是两个可以调用的函数。***



## 加油站2：关于`set_new_handler`函数

> 知识点加油站：
>
> 参考博客：https://blog.csdn.net/wzxq123/article/details/51502356
>
> 关于`set_new_handler`函数的使用方法，***该函数的主要作用就是当我们new操作或者new []操作失败的时候调用的处理函数。***设置的处理函数可以尝试使得更多空间变为可分配的状态，这样的话新一次的`new`操作就可能成功。
>
> 当我们没有使用该函数去设置处理函数的时候，或者设置的处理函数为空的时候，***其将会调用默认的处理函数，该函数在内存分配失败的时候抛出`bad_alloc异常`。***
>
> 这里注意，我们下面的写法都是设置处理函数为空：
>
> ```C++
> std::set_new_handler(0);
> std::set_new_handler(nullptr);
> ```
>
> 源码中关于该函数是这样定义的：
>
> ```C++
> // defined in header <new>
> 
> typedef void(*new_handler)();
> // 1. 即将将函数指针起了一个别名, 叫做new_handler
> // 这样的话会有利于我们去理解相关的函数
> 
> // 2. 下面是set_new_handler函数的声明,分别是两种不同的声明 
> new_handler set_new_handler(new_handler new_p) throw(); // C++98
> new_handler set_new_handler(new_handler new_p) noexcept;// C++11
> 
> // 3. 关于throw和noexcept，其实就是声明函数不会抛出任何异常，即使我们函数在执行的过程中有抛出异常，但是我们不会去捕捉，仅仅是终止程序的执行
> 
> // 4. 如果说我们设置的处理函数为空的话，该函数就会在内存分配失败的时候抛出`bad_alloc`异常
> 
> ```
>
> 实例代码：
>
> ```C++
> #include <iostream>
> #include <new>
>  
> void handler()
> {
>     std::cout << "Memory allocation failed, terminating\n";
>     std::set_new_handler(0);
> }
>  
> int main()
> {
>     std::set_new_handler(handler);
>     try {
>         while (true) {
>             new int[1000'000'000ul]();
>         }
>     } catch (const std::bad_alloc& e) {
>         std::cout << e.what() << '\n';
>     }
> }
> ```
>
> 上面的代码中，我们第一次分配内存失败的时候回去执行handler函数，即我们自定义的函数，在执行的过程中又将处理函数设置为默认的处理函数，接着程序就会捕获到内存分配失败事件，从而产生`bad_alloc`异常，由于该异常很特殊，所以说catch可以捕获到。

## 加油站3：new的三种形态

> 参考文章：https://www.cnblogs.com/fnlingnzb-learner/p/8515183.html
>
> - new operator, 就是我们经常使用的new操作符；
> - operator new， 这个是我们的new操作符做的事情中的第一件，使用函数`operator new`来申请空间；
> - placement new, 此种就是我们上面所提到的new的第三种形态；
>
> new的第三种形态使用来实现定位构造的，也就是说我们申请完内存之后，在获得的内存上构造一个对象，有点类似于前面代码中的`p->A :: A(3)`, 但是这个并不是一个标准的写法，正确的写法是使用`placement new`。
>
> ```C++
> #include <new.h>
> 
> void main()
> {
>    char s[sizeof(A)];
>    A* p = (A*)s;
>    new(p) A(3); //p->A::A(3);
>  // 即后面的A（3）显式的调用了构造函数来给前面指向的内存赋值
>    p->Say();
> }
> ```
>
> 我们一般是不使用这样的写法的，因为我们使用new操作符的时候编译器就会自动的将其编译并生成对placement new的调用的代码。***当我们觉得默认的new operator对内存的管理不能满足我们的需要，而希望自己手工的管理内存时，placement new就有用了。STL中的allocator就使用了这种方式，借助placement new来实现更灵活有效的内存管理。***



# 1. `allocator`必要的接口

```C++
// 这里的接口可以理解为该类中必须要有这样的实现与声明，来供我们调用
allocator::value_type;			// 变量的类型
allocator::pointer;					// 指针
allocator::const_pointer;
allocator::reference;				// 引用
allocator::const_reference;
allocator::size_type;       // 分配的大小的类型
allocator::difference_type;	// 该类型是迭代器之间的距离的类型

allocator::rebind;  // 一个嵌套的类模板，该类中只有一个成员typedef allocator<U> other

allocator::allocator(); // 默认的构造函数

allocator::allocator(const allocator&); // 拷贝构造函数

template<class U>allocator::allocator(const allocator<U> &) // 泛化的 allocator 构造函数
  
allocator::~allocator(); // 析构函数

pointer allocator::address(reference x) const;
// 返回某一个对象的地址,a.address(x) 相当于&x, 所以我们将参数设置为引用，这样才可以真正获得对象的真正地址。
const_pointer allocator::address(const_reference x) const; // 获得某一个const对象的地址

pointer allocator::allocate(size_type n, const T&x);// 该函数的作用是配置空间，足以存储n个T对象，第二个参数是一个提示，这里就相当于我们new操作符中的operator new函数

void allocator::deallocate(pointer p, size_type n);// 归还先前配置的内存空间，就相当于new操作符中的operator new函数

size_type allocator::max_size() const; // 返回成功配置的最大内存空间的量

void allocator::construct(pointer p, const T& x);// 等同于new ((void*) p) T(x),这里是new操作的第三种形态，具体查看加油站3相关知识点

void allocator::destory(pointer p); // 等同于调用p->~T(),这里是由于STL使用了placement，编译器不会自动产生调用析构函数的代码，需要我们手工的去实现


```

# 2. SGI STL的空间分配器

> 这里只需要我们了解一下即可，SGI STL的分配器和我们标准规范是不一样的，其名称是`alloc`而非是`allocator`，而且不接受任何参数。就是说按照SGI的标准，我们不能按照标准写法去定义一个变量：
>
> ```C++
> vector<int, std::allocator<int>> iv;
> ```
>
> 我们需要按照SGI的规格来写，当然了这只是针对SGI标准下的写法，我们平时写的代码都是按照STL标准来的。
>
> ```C++
> vector<int, std::alloc> iv;
> ```
>
> 你也可以去看看其是怎么定义的，我们不需要传进去任何参数： [stl_alloc.h](stl_source_code/sgi-stl-master/g++/stl_alloc.h) 

当然了，SGI也是定义了一个符合部分标准，名为`allocator`的分配器，但是其并未使用，也建议我们不使用，因为其效率不佳！

 [defalloc.h](stl_source_code\sgi-stl-master\g++\defalloc.h) 

我们可以看他写的源码，可以看到仅仅是非常简单的申请内存，然后初始化等等。



一般而言，我们习惯的C++内存配置操作和释放是这样的：

```c++
class Foo{}
Foo * pf = new Foo;
delete pf;
```

其中的具体知识点请参考加油站1的相关内容。



看完上面的知识点之后，我们回头看STL allocator，也会发现STL allocator也是将new和delete的操作进行了分离：

- 内存分配：该部分是由`alloc::allocate()`负责的；
- 内存释放：该部分是由`alloc::deallocate()`负责的；
- 对象构造：是由`alloc::construct()`负责的；
- 对象析构：是由`alloc::destroy`负责的；





[1.语法示例](#1.1)

