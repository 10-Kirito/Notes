# 1. 矩阵相乘

## 1. 串行程序

```C++
❯ g++ matrix_multi.cpp -o matrix_multi
❯ ./matrix_multi
Initialize Matrix_1 finished
Initialize Matrix_2 finished
Result: 
Cost time: 121859 ms
```

## 2. 并行程序版本

```C++
#pragma omp parallel for shared(a, b, result) private(j, k) schedule(dynamic)  
    // #pragma omp parallel for 
    for (i = 0; i < max; i++) {
      for (j = 0; j < max; j++) {
        int temp = 0;
        for (k = 0; k < max; k++) {
          temp += a[i][k]* b[k][j];
        }
        result[i][j] = temp;
      }
    }
```

```output
❯ lvim matrix_multi_parallel_v1.cpp
❯ g++ -fopenmp matrix_multi_parallel_v1.cpp -o parallel_v1
❯ ./parallel_v1
Initialize Matrix_1 finished
Initialize Matrix_2 finished
Result: 
Cost time: 20700 ms
The Max of error is :0
Average Error is :0
```

我们经过计算可以得到加速比为5.89。

# 2. 计算π的积分

求出$\int_{0}^{1}\frac{4}{1+x^{2}}\frac{\mathrm{d} }{\mathrm{d} x}$的值。

## 2.1 串行程序

```C++
#include <iostream>
#include <chrono>

using namespace std;

static long num_step = 100000000;
double step;
int main (int argc, char *argv[])
{
  int i;
  double x, pi, sum = 0.0;
  
  step = 1.0/(double) num_step;

  
  chrono::milliseconds start_time = chrono::duration_cast<chrono::milliseconds>(chrono::system_clock::now().time_since_epoch());
  for (i = 0; i < num_step; ++i) {
    x = (i + 0.5) * step;
    // x = (i + 0.4) * step;
    sum = sum + 4.0/(1.0 + x * x);
  }
  chrono::milliseconds end_time = chrono::duration_cast<chrono::milliseconds>(chrono::system_clock::now().time_since_epoch());
  pi = step * sum;
  
  std::cout <<"The result: "<< pi << std::endl;
  cout << "cost time: " <<  chrono::milliseconds(end_time).count() - chrono::milliseconds(start_time).count() << "ms" << endl;

  return 0;
}
```

运行结果：

```C++
❯ g++ first.cpp -o first
❯ ./first
The result: 3.14159
cost time: 215ms
```

## 2.2 并行程序

```C++
#include <iostream>
#include <chrono>
#include <omp.h>
using namespace std;

static long num_step = 100000000;
double step;
#define NUM_THREADS 8
int main (int argc, char *argv[])
{
  
  double pi = 0.0;
  step = 1.0/(double) num_step;
  int number;

  
  chrono::milliseconds start_time = chrono::duration_cast<chrono::milliseconds>(chrono::system_clock::now().time_since_epoch());
  omp_set_num_threads(NUM_THREADS);
  #pragma omp parallel
  {
    int i, id, nthreads;
    double x, sum;
    id = omp_get_thread_num();
    nthreads = omp_get_num_threads();
    if (id == 0) {
      number = nthreads;
    }
    #pragma omp for
    for (i = 0; i < num_step; ++i) {
      x = (i + 0.5) * step;
      // x = (i + 0.4) * step;
      sum = sum + 4.0/(1.0 + x * x);
    }
    #pragma omp critical
    pi = step * sum;
  }
  chrono::milliseconds end_time = chrono::duration_cast<chrono::milliseconds>(chrono::system_clock::now().time_since_epoch());
    
  std::cout <<"The result: "<< pi << std::endl;
  cout << "cost time: " <<  chrono::milliseconds(end_time).count() - chrono::milliseconds(start_time).count() << "ms" << endl;

  return 0;
}

```

程序执行结果：

```C++
❯ ./PI_Parallel_v2
The result: 0.719414
cost time: 89ms
```

我们经过计算可以得到加速比为2.42.
