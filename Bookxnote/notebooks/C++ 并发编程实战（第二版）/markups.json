{"EpubVersion":2,"filepath":"","floatingtheme":[],"folded":false,"markups":[{"date":"2022-12-28 18:20:53","docid":0,"id":1,"imgfile":"ea02b49649db8b1ead59716e989c2dc8.png","linecolor":"ffa0ec6f","linewidth":2,"page":51,"rect":[67.99999797344213,501.4999850541358,381.49998863041435,536.4999840110545],"toprightcorner":[381.49998863041435,501.4999850541358],"type":2,"uuid":"b43693df70b1b61838a7e3a42660c84d"},{"date":"2022-12-28 18:22:24","docid":0,"fillcolor":"ffffed99","id":2,"originaltext":"因为在调用empty()①和调用top()②之间，可能有来自另一个线程的pop()调用并删除了最后一个元素。这是一个经典的条件竞争，","page":52,"textblocks":[{"first":[181.05654907226562,200.08653259277344,9.004989624023438,9.004989624023438],"last":[253.09646606445312,214.34434509277344,9.0050048828125,9.004989624023438],"length":67,"rects":[[181.05654907226562,200.08653259277344,331.2016296386719,9.004989624023438],[82.00164031982422,214.34434509277344,180.0998306274414,9.004989624023438]],"start":189,"text":"因为在调用empty()①和调用top()②之间，可能有来自另一个线程的pop()调用并删除\n了最后一个元素。这是一个经典的条件竞争，"}],"type":5,"uuid":"78c2ca8eed52bad9bda643ae323942cd"},{"date":"2023-01-02 21:59:29","docid":0,"fillcolor":"ffffed99","id":4,"originaltext":"这就是为什么用 std::unique_lock 而不使用 std::lock_guard 的原因——等待中的线程必须在等待期间解锁互斥量，并对互斥量再次上锁，而 std::lock_guard 没有这么灵活。","page":78,"textblocks":[{"first":[118.0216064453125,166.6522674560547,9.004989624023438,10.193267822265625],"last":[351.0257568359375,181.32615661621094,9.0050048828125,9.004989624023438],"length":106,"rects":[[118.0216064453125,166.6522674560547,388.6802673339844,10.193267822265625],[82.00164031982422,181.32615661621094,278.0291213989258,9.004989624023438]],"start":361,"text":"这就是为什么用 std::unique_lock 而不使用 std::lock_guard 的原因——等待中的线程必须在等待期间\n解锁互斥量，并对互斥量再次上锁，而 std::lock_guard 没有这么灵活。"}],"type":5,"uuid":"6f12b4cfe5d0c9395313575571911031"}],"maxid":4,"notelinks":[],"title":"C++ 并发编程实战（第二版）","unimportant":[]}